<link rel="import" href="./scene.html">
<link rel="import" href="./player.html">
<link rel="import" href="./sound-manager.html">
<link rel="import" href="./log.html">
<link rel="import" href="./sections/asteroid-single.html">
<link rel="import" href="./sections/asteroids-multi.html">
<link rel="import" href="./sections/asteroid-belt.html">
<link rel="import" href="./sections/paddles.html">
<link rel="import" href="./marker.html">
<link rel="import" href="./socket-manager.html">
<link rel="import" href="./mouse-manager.html">
<link rel="import" href="./portal.html">
<script>
    const STARTING_ANIM_MS = 1000;
    const GENERATE_PADDING = 200
    const SECTIONS_INDEX = [
        //{ constr: SectionPaddles, likelyhood: 1 },
        { constr: SectionAsteroidSingle, likelyhood: 1 },
        //{ constr: SectionAsteroidsMulti, likelyhood: 1 },
        //{ constr: SectionAsteroidBelt, likelyhood: 1 },
    ]

    class Level {
        constructor (ctx, json) {
            this.descriptor = json;
            this.scene = new Scene(ctx);
            this.player = new Player(this.scene, {
                x: this.scene.width / 2,
                y: this.scene.height
            });
            let rect = this.player.getRect();
            this.player.move(0, rect.height);
            this.playerLimit = this.scene.height - 200;
            this.offset = 0;
            this.sections = [];
            this.markers = [];

            this.entryPortal = null;
            this.exitPortal = null;

            Socket.on('add-marker', (e) => {
                this.addMarker(e.x, e.y);
            });

            if (Socket.isDriver) {
                setInterval(() => {
                    Socket.send('player-state', this.player.toJSON());
                }, 16);
                Socket.on('place-portal', (e) => {
                    this.placePortal(e.x, e.y);
                });
            } else {
                Socket.on('player-state', (e) => {
                    this.player.updateState(e);
                });
                Socket.on('portal-destroyed', (e) => {
                    if (e.type === 'entry') {
                        this.entryPortal.destroy();
                        this.entryportal = null;
                    }
                });
            }

            Mouse.onDown((e) => {
                if (!e.rightClick) {
                    Socket.send('add-marker', { x: e.x, y: e.y });
                    this.addMarker(e.x, e.y);
                } else {
                    if (!Socket.isDriver) {
                        Socket.send('place-portal', { x: e.x, y: e.y });
                        this.placePortal(e.x, e.y);
                    }
                }
            });

            Sound.load('noise' ,'/assets/sounds/noise.wav');
        }

        placePortal (x, y) {
            if (!this.entryPortal) {
                this.entryPortal = new Portal(this.scene, { x, y, type: 'entry' });
                this.scene.addElement(this.entryPortal);
            } else if (!this.exitPortal) {
                this.exitPortal = new Portal(this.scene, { x, y, type: 'exit' });
                this.exitPortal.setBoundPortal(this.entryPortal);
                this.entryPortal.setBoundPortal(this.exitPortal);
                this.scene.addElement(this.exitPortal);
            } else {
                this.scene.removeElement(this.entryPortal);
                this.scene.removeElement(this.exitPortal);
                this.entryPortal = null;
                this.exitPortal = null;
                this.placePortal(x, y);
            }
        }

        addMarker (x, y) {
            let m = new Marker(this.scene.ctx, { x, y });
            this.markers.push(m);
            this.scene.addElement(m);
        }

        getNextSection (scene) {

        }

        update (dt) {
            let collisions,
                now = Date.now(),
                totalSectionHeight,
                lastSection,
                firstSection,
                since;
            totalSectionHeight = this.sections.reduce((acc, section) => {
                return acc + section.height;
            }, 0);
            firstSection = this.sections[0];
            lastSection = this.sections[this.sections.length - 1];

            if (!this.sections.length || totalSectionHeight < this.scene.height) {
                let { height, y } = lastSection || {}
                let newSection = this.generateSection(y - GENERATE_PADDING, height);
                this.scene.addElement(newSection);
                this.sections.push(newSection);
            }

            if (firstSection && firstSection.y - firstSection.height > this.scene.height) {
                this.scene.removeElement(this.sections.shift());
            }

            if (this.started) {
                since = now - this.started;

                if (since <= STARTING_ANIM_MS) {
                    let e = EasingFunctions.easeOutQuad(since / STARTING_ANIM_MS);
                    this.player.moveTo(this.player.x, this.scene.height - 200 * e);
                } else {
                    this.started = null;
                }
            }

            Logger.log("Player y: " + this.player.y);
            Logger.log("Player limit: " + this.playerLimit);

            // Slow down if the player has been hit
            let d = (this.player.hitDelay ? 0.2 : 0.4) * dt;
            this.offset += d;

            if (!this.frozen) {
                this.sections.forEach(section => {
                    section.move(0, d);
                });

                this.markers.forEach(marker => {
                    marker.move(0, d);
                });

                if (this.entryPortal) {
                    this.entryPortal.move(0, d);
                }

                if (this.exitPortal) {
                    this.exitPortal.move(0, d);
                }

                if (this.player.y < this.playerLimit) {
                    this.player.move(0, d);
                }

            }
            this.scene.update(dt);
            collisions = this.scene.world.getCollisions('player');
            collisions.forEach(col => {
                console.log('hit');
                if (col.data && col.data.collisionCallback) {
                    col.data.collisionCallback(this.player);
                }
            });

            if (this.entryPortal) {
                collisions = this.scene.world.getCollisions(this.entryPortal.body.id);
                collisions.forEach(col => {
                console.log('hit');
                if (col.data && col.data.collisionCallback) {
                    col.data.collisionCallback(this.entryPortal);
                }
            });
            }

            if (this.player.dead) {
                this.freeze();
            }
        }

        freeze () {
            this.frozen = true;
        }

        generateSection(y, height) {
            let Constr;
            let ltotal = 0;
            let lcur = 0;
            let ltarget;

            for (let section of SECTIONS_INDEX) {
                ltotal += section.likelyhood;
            }

            ltarget = Math.random() * ltotal;

            for (let section of SECTIONS_INDEX) {
                if (lcur + section.likelyhood > ltarget) {
                    Constr = section.constr;
                    break;
                }

                lcur += section.likelyhood;
            }

            let section = new Constr(this.scene, { x: 0, y: 0 });
            section.move(0, (y || 0) + (-height || 0));

            return section
        }

        render () {
            this.scene.render();
        }

        start () {
            this.started = Date.now();
        }
    }
</script>